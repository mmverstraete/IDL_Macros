<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
   <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Documentation for the IDL routines in project Macros</title>
   </head>
<body>
<h1>Documentation for the IDL routines in project Macros</h1>
<h2>is_alphanum</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is alphanumeric or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_alphanum(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if the type of <code>arg</code> is either <code>STRING</code> (7) or one of the numeric types: <code>BYTE</code> (1), <code>INT</code> (2), <code>LONG</code> (3), <code>FLOAT</code> (4), <code>DOUBLE</code> (5), <code>COMPLEX</code> (6), <code>DCOMPLEX</code> (9), <code>UINT</code> (12), <code>ULONG</code> (13), <code>LONG64</code> (14) or <code>ULONG64</code> (15), and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_alphanum(&#39;Hi&#39;)
       1

IDL&gt; PRINT, is_alphanum(1.2)
       1

IDL&gt; PRINT, is_alphanum(PTR_NEW(0b))
       0

IDL&gt; PRINT, is_alphanum()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_array</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is an array or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the dimension of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_array(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is an array, (i.e., has at least one dimension), and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_array([1, 2, 3])
       1

IDL&gt; PRINT, is_array([&#39;abc&#39;, &#39;def&#39;])
       1

IDL&gt; PRINT, is_array(3)
       0

IDL&gt; PRINT, is_array()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_byte</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>BYTE</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_byte(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>BYTE</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>BYTE</code> variable represents an unsigned 8-bit integer number, which can take values between 0 and 255, but small integers in that range are not characterized as bytes, unless explicitly stated: the default type for integers is a 16-bit <code>INT</code>.</p></li>
<li><p><strong>Note 3:</strong> Within the <code>ASCII</code> context, there is a direct relation between integers in the range 0 to 255 and corresponding character representations, but these are not interchangeable in <code>IDL</code>. See the following examples.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 72B
IDL&gt; res = is_byte(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = STRING(a)
IDL&gt; PRINT, b
H
IDL&gt; res = is_byte(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, BYTE(&#39;H&#39;)
  72
IDL&gt; c = 72
IDL&gt; res = is_byte(c)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_byte()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_complex</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>COMPLEX</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_complex(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>COMPLEX</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a variable of type <code>COMPLEX</code> is represented as a couple of real numbers, but an array of two real numbers is not considered a complex number.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = COMPLEX(1.0, 2.0)
IDL&gt; res = is_complex(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = [12.3, 45.6]
IDL&gt; res = is_complex(b)
IDL&gt; PRINT, res
       0

IDL&gt; res = is_complex(&#39;test&#39;)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_complex()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_dcomplex</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>DCOMPLEX</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_dcomplex(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>DCOMPLEX</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a variable of type <code>DCOMPLEX</code> is represented as a couple of double precision real numbers, but an array of two double precision real numbers is not considered a complex number.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; c = DCOMPLEX(3.0D, 4.0D)
IDL&gt; res = is_dcomplex(c)
IDL&gt; PRINT, res
       1

IDL&gt; res = is_dcomplex([12.3D, 45.6D])
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_dcomplex()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_defined</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is defined or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine whether the input positional parameter <code>arg</code> is defined or not.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_defined(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is defined, and <code>0</code> if it is <code>UNDEFINED</code> (Type 0).</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = [1, 2, 3]
IDL&gt; res = is_defined(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = !NULL
IDL&gt; res = is_defined(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_defined()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_double</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>DOUBLE</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_double(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>DOUBLE</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>DOUBLE</code> variable represents a double precision floating point number, which can take values within a range that is hardware-dependent. The <code>IDL</code> function <code>MACHAR(/DOUBLE)</code> reports the extent of this range, for instance <code>[2.2E-308, 2.0E+308]</code> for a 64-bit machine, where the mantissa will feature at least 15 and no more than 16 significant digits.</p></li>
<li><p><strong>Note 3:</strong> A <code>DCOMPLEX</code> variable is not considered of type <code>DOUBLE</code>, even though the real and the imaginary components, taken individually, are of type <code>DOUBLE</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 3.14159D
IDL&gt; res = is_double(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = DCOMPLEX(12.3D, 4.56D)
IDL&gt; res = is_double(b)
IDL&gt; PRINT, res
       0
IDL&gt; res = is_double(IMAGINARY(b))
IDL&gt; PRINT, res
       1

IDL&gt; PRINT, is_double()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_float</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>FLOAT</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_float(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>FLOAT</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>FLOAT</code> variable represents a single precision floating point number, which can take values within a range that is hardware-dependent. The <code>IDL</code> function <code>MACHAR()</code> reports the extent of this range, for instance <code>[1.2E-38, 3.4E+38]</code> for a 64-bit machine, where the mantissa will feature at least 6 and no more than 7 significant digits.</p></li>
<li><p><strong>Note 3:</strong> If a real number with more than 7 significant digits is assigned to a variable without specifying that it should be saved in double precision, the variable will contain a truncated representation of that number, and thus be considered of type <code>FLOAT</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 1.23
IDL&gt; res = is_float(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 5
IDL&gt; res = is_float(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = 1.23456789
IDL&gt; res = is_float(c)
IDL&gt; PRINT, res
       1
IDL&gt; PRINT, c
      1.23457
IDL&gt; PRINT, c, FORMAT = &#39;(F10.8)&#39;
      1.23456788

IDL&gt; PRINT, is_float()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_int</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>INT</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_int(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>INT</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, an <code>INT</code> variable represents a signed 16-bit integer number, which can take values between <code>-32,768</code> and <code>+32,767</code>. Natural numbers beyond this range can be used, but should be declared as <code>LONG</code>, <code>ULONG</code>, <code>LONG64</code> or <code>ULONG64</code>.</p></li>
<li><p><strong>Note 3:</strong> Note the strict interpretation of the type <code>INT</code>. See the function <code>is_integer</code> for a generic test allowing any one of the <code>INTEGER</code> types.</p></li>
<li><p><strong>Note 4:</strong> Contrary to the case of floating point numbers (see subsection <a href="#subsec:isfloat" data-reference-type="ref" data-reference="subsec:isfloat">[subsec:isfloat]</a> above), if an integer constant larger than <span class="math inline">&#8197;+&#8197;32,&#8198;767</span> is assigned to a variable, the latter becomes a <code>LONG</code> integer.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 10
IDL&gt; res = is_int(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 1.23
IDL&gt; res = is_int(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = 40000
IDL&gt; res = is_int(c)
IDL&gt; PRINT, res
       0
IDL&gt; PRINT, is_long(c)
       1

IDL&gt; PRINT, is_INT()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_integer</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of one of the integer types or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_integer(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>INT</code>, <code>UINT</code>, <code>LONG</code>, <code>ULONG</code>, <code>LONG64</code>, or <code>ULONG64</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, an <code>INT</code> variable represents a signed 16-bit integer number, which can take values between <code>-32,768</code> and <code>+32,767</code>; a <code>UINT</code> variable represents an unsigned 16-bit integer number, which can take values between <code>0</code> and <code>65,535</code>; a <code>LONG</code> variable represents an unsigned 32-bit integer number, which can take values between <code>&#8211;2,147,483,648</code> and <code>+2,147,483,647</code>; a <code>ULONG</code> variable represents an unsigned 32-bit integer number, which can take values between <code>0</code> and <code>4,294,967,295</code>; a <code>LONG64</code> variable represents an unsigned 64-bit integer number, which can take values between <code>&#8211;9,223,372,036,854,775,808</code> and <code>+9,223,372,036,854,775,807</code>; a <code>ULONG64</code> variable represents an unsigned 64-bit integer number, which can take values between <code>0</code> and <code>18,446,744,073,709,551,615</code>.</p></li>
<li><p><strong>Note 3:</strong> Note the more permissive interpretation of type <code>INTEGER</code>, which returns a positive answer for any one of the 6 types of integer numbers allowed in <code>IDL</code>.</p></li>
<li><p><strong>Note 4:</strong> Contrary to the case of floating point numbers, if an integer constant larger than <span class="math inline">&#8197;+&#8197;32,&#8198;767</span> is assigned to a variable, the latter becomes a <code>LONG</code> integer.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 10
IDL&gt; res = is_integer(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 1.23
IDL&gt; res = is_integer(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = 40000
IDL&gt; PRINT, is_integer(c)
       1
IDL&gt; PRINT, is_int(c)
       0
IDL&gt; PRINT, is_long(c)
       1

IDL&gt; d = -9223372036854LL
IDL&gt; res = is_integer(d)
IDL&gt; PRINT, res
       1

IDL&gt; PRINT, is_integer()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_letter</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the (presumably single character) input positional parameter <code>char</code> is one of the 27 letters (lowercase or uppercase) of the ASCII character set or not.</p></li>
<li><p><strong>Algorithm:</strong> This function checks whether the <code>BYTE</code> representation of <code>char</code> is within the ranges [65, 90] or [97, 122] to determine whether it corresponds to a letter.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = is_letter, char)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>char {STRING} [I]:</code> An arbitrary 1-character long variable.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if the input positional parameter <code>char</code> is an uppercase or a lowercase letter, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function does not check whether the input positional parameter is of type <code>STRING</code> and composed of a single character: If that is not the case, results may be unreliable at best, or may cause IDL to crash. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_letter(&#39;c&#39;)
       1

IDL&gt; PRINT, is_letter(&#39;M&#39;)
       1

IDL&gt; PRINT, is_letter(&#39;$&#39;)
       0

IDL&gt; PRINT, is_letter(123)
       0

IDL&gt; PRINT, is_letter(&#39;123&#39;)
% Expression must be a scalar or 1 element array
   in this context: &lt;BYTE Array[3]&gt;.
% Execution halted at: IS_LETTER...</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;12&#8211;02: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_long</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>LONG</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_long(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>LONG</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>LONG</code> variable represents an unsigned 32-bit integer number, which can take values between <code>&#8211;2,147,483,648</code> and<br />
<code>+2,147,483,647</code></p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 123456789L
IDL&gt; res = is_long(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 12
IDL&gt; res = is_long(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_long()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_long64</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>LONG64</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_long64(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>LONG64</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>LONG64</code> variable represents a signed 64-bit integer number, which can take values between<br />
<code>&#8211;9,223,372,036,854,775,808</code> and <code>+9,223,372,036,854,775,807</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_long64(123LL)
       1

IDL&gt; PRINT, is_long64(123456UL)
       0

IDL&gt; PRINT, is_long64()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_numeric</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is a number or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_numeric(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of one of the numeric types (type codes <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>9</code>, <code>12</code>, <code>13</code>, <code>14</code>, or <code>15</code>), and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; .reset
IDL&gt; PRINT, is_numeric(zzz)
       0

IDL&gt; a = 12B
IDL&gt; res = is_numeric(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = &#39;Hello&#39;
IDL&gt; res = is_numeric(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = 12.3
IDL&gt; res = is_numeric(c)
IDL&gt; PRINT, res
       1

IDL&gt; PRINT, is_numeric()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_numstring</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is a <code>STRING</code> that contains only digits, arithmetic signs, or the decimal point, or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine whether the input positional parameter <code>arg</code> is a <code>STRING</code>, and then checks whether each and every character in that string is a digit, or an arithmetic sign, or the decimal point.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_numstring(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>STRING</code> and if each character of that string is either a digit (0 to 9), or a sign (<code>+</code> or <code>-</code>), or a decimal point, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = &#39;123&#39;
IDL&gt; PRINT, is_numstring(a)
       1

IDL&gt; b = &#39;2*4/3&#39;
IDL&gt; PRINT, is_numstring(b)
       0

IDL&gt; c = &#39;-567.89&#39;
IDL&gt; PRINT, is_numstring(c)
       1

IDL&gt; d = &#39;4x&#39;
IDL&gt; PRINT, is_numstring(d)
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;08&#8211;07: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_objref</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>OBJREF</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_objref(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>OBJREF</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; A = OBJARR(3, 3)
IDL&gt; res = is_objref(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 1.23
IDL&gt; res = is_objref(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_objref()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_pointer</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>POINTER</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_pointer(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>POINTER</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 12.3
IDL&gt; b = PTR_NEW(TEMPORARY(a))
IDL&gt; res = is_pointer(b)
IDL&gt; PRINT, res
       1

IDL&gt; c = 1234UL
IDL&gt; res = is_pointer(c)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_pointer()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_positive</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of numeric type and equal to or greater than <code>0.0</code>, or not.</p></li>
<li><p><strong>Algorithm:</strong> This function tests whether the input positional parameter <code>arg</code> is of a numeric type, and if so, whether it is equal to or greater than <code>0.0</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_positive(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary numeric expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is both of numeric type and equal to or larger than <code>0</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> This function considers complex numbers to be always positive, independently from the sign of the real and imaginary parts.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_positive(1234)
       1

IDL&gt; PRINT, is_positive(0.0)
       1

IDL&gt; PRINT, is_positive(-0.1E-20)
       0

IDL&gt; PRINT, is_positive(&#39;12&#39;)
       0

IDL&gt; PRINT, is_positive(COMPLEX(-1.0, 0.0))
       1

IDL&gt; PRINT, is_positive(COMPLEX(1.0, -20.0))
       1

IDL&gt; PRINT, is_positive(COMPLEX(-1.0, -20.0))
       1

IDL&gt; PRINT, is_positive()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_scalar</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is a scalar (i.e., does not have a dimension) or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_scalar(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is a scalar, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 3.14
IDL&gt; res = is_scalar(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = [5, 6, 7]
IDL&gt; res = is_scalar(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = CREATE_STRUCT(&#39;A&#39;, 1, &#39;B&#39;, &#39;xxx&#39;)
IDL&gt; res = is_scalar(c)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_scalar()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_single</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is a single precision integer, floating point or complex number or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_single(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>BYTE</code> (1), <code>INT</code> (2), <code>FLOAT</code> (4), <code>COMPLEX</code> (6), <code>UINT</code> (12), and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_single(2)
       1

IDL&gt; PRINT, is_single(5B)
       1

IDL&gt; PRINT, is_single(COMPLEX(3.5, 1.0))
       1

IDL&gt; PRINT, is_single(345LL)
       0

IDL&gt; PRINT, is_single(DOUBLE(78.0))
       0

IDL&gt; PRINT, is_single()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_string</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>STRING</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_string(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>STRING</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> This function works equally well for scalars and arrays.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = &#39;Hello&#39;
IDL&gt; res = is_string(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 12.34
IDL&gt; res = is_string(b)
IDL&gt; PRINT, res
       0

IDL&gt; c = [&#39;Hello&#39;, &#39;World&#39;]
IDL&gt; res = is_string(c)
IDL&gt; PRINT, res
       1

IDL&gt; PRINT, is_string()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_struct</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>STRUCT</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_struct(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>STRUCT</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = CREATE_STRUCT(&#39;A&#39;, 1, &#39;B&#39;, &#39;xxx&#39;)
IDL&gt; res = is_struct(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 12.3D
IDL&gt; res = is_struct(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_struct()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_uint</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>UINT</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_uint(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>UINT</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>UINT</code> variable represents an unsigned 16-bit integer number, which can take values between <code>0</code> and <code>65,535</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_uint(123U)
       1

IDL&gt; PRINT, is_uint(123)
       0

IDL&gt; PRINT, is_uint()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_ulong</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>ULONG</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_ulong(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>ULONG</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>ULONG</code> variable represents an unsigned 32-bit integer number, which can take values between <code>0</code> and <code>4,294,967,295</code></p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, is_ulong(123456789UL)
       1

IDL&gt; PRINT, is_ulong(12L)
       0

IDL&gt; PRINT, is_ulong()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_ulong64</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>arg</code> is of type <code>ULONG64</code> or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_ulong64(arg)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>1</code> if <code>arg</code> is of type <code>ULONG64</code>, and <code>0</code> otherwise.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
<li><p><strong>Note 2:</strong> Within the <code>IDL</code> context, a <code>ULONG64</code> variable represents an unsigned 64-bit integer number, which can take values between <code>0</code> and<br />
<code>18,446,744,073,709,551,615</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 1234567890ULL
IDL&gt; res = is_ulong64(a)
IDL&gt; PRINT, res
       1

IDL&gt; b = 1234567890LL
IDL&gt; res = is_ulong64(b)
IDL&gt; PRINT, res
       0

IDL&gt; PRINT, is_ulong64()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>set_white</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a 2-character <code>STRING</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function does not accept any input positional parameters and returns a string containing two characters: a <code>TAB</code> and a <code>SPACE</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>white = set_white()</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns a 2-character <code>STRING</code> containing a <code>TAB</code> and a <code>SPACE</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function may be useful to split a string on white space when the nature of the apparent white space is unknown, or when both characters may appear in the same string.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; line = &#39;This line contains a TAB&#39; + STRING(9B) + $
   &#39;character.&#39;
IDL&gt; PRINT, line
This line contains a TAB    character.
IDL&gt; white = set_white()
IDL&gt; parts = STRSPLIT(line, white, COUNT = n_parts, /EXTRACT)
IDL&gt; PRINT, &#39;n_parts = &#39;, n_parts
n_parts =            6
IDL&gt; FOR i = 0, n_parts-1 DO PRINT, i, &#39;   &gt;&#39; + parts[i] + &#39;&lt;&#39;
       0   &gt;This&lt;
       1   &gt;line&lt;
       2   &gt;contains&lt;
       3   &gt;a&lt;
       4   &gt;TAB&lt;
       5   &gt;character.&lt;

IDL&gt; parts = STRSPLIT(line, &#39; &#39;, COUNT = n_parts, /EXTRACT)
IDL&gt; PRINT, &#39;n_parts = &#39;, n_parts
n_parts =            5
IDL&gt; FOR i = 0, n_parts-1 DO PRINT, i, &#39;   &gt;&#39; + parts[i] + &#39;&lt;&#39;
       0   &gt;This&lt;
       1   &gt;line&lt;
       2   &gt;contains&lt;
       3   &gt;a&lt;
       4   &gt;TAB character.&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>type_of</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports the type code and the type name of the input positional parameter <code>arg</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>SIZE()</code> to determine the type of the input positional parameter.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = type_of(arg, type_code, type_name)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg [I]</code>: An arbitrary expression.</p></li>
<li><p><code>type_code {INT} [O]:</code> The type code of the input positional parameter <code>arg</code>.</p></li>
<li><p><code>type_name {STRING} [O]:</code> The type name of the input positional parameter <code>arg</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns <code>0</code> and reports the type code and the type name of the input positional parameter <code>arg</code> in the 2 output positional parameters <code>type_code</code> and <code>type_name</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function accepts any type of input positional parameter, including none at all, in which case it returns <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 36B
IDL&gt; rc = type_of(a, type_code, type_name)
IDL&gt; PRINT, type_code, &#39;   &#39;, type_name
           1   BYTE

IDL&gt; b = 987.32
IDL&gt; rc = type_of(b, type_code, type_name)
IDL&gt; PRINT, type_code, &#39;   &#39;, type_name
           4   FLOAT

IDL&gt; c = &#39;Hello World!&#39;
IDL&gt; rc = type_of(c, type_code, type_name)
IDL&gt; PRINT, type_code, &#39;   &#39;, type_name
           7   STRING

IDL&gt; PRINT, type_of()
       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
</body>
</html>
